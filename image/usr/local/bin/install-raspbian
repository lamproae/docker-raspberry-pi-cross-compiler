#!/usr/bin/perl
use 5.14.0;
use warnings;
use File::Find qw(find);
use File::Temp qw(tempdir);

my $local_root = '/rpxc';

die "usage: $0 package [packages...]" unless @ARGV;

my $arch = 'armhf';
main(@ARGV);
exit 0;

sub main {
    my $manifest = "$local_root/raspbian-manifest";
    my $dir = tempdir(CLEANUP => 1);
    chdir($dir);

    my $installed = read_manifest($manifest);
    my $requested_packages = filter_requested_list($installed, \@_);
    if (!@$requested_packages) {
        say "Nothing to do";
        exit 0;
    }

    fetch_package_list($ENV{RASPBIAN_PACKAGE_URL}, $ENV{RASPBIAN_PACKAGE_FILE});
    my $packages = load_package_list($ENV{RASPBIAN_PACKAGE_FILE});

    my $installation_list = process_dependencies($installed, $packages, $requested_packages);

    if (@$installation_list) {
        download_packages($installation_list);
        install_packages($ENV{RASPBIAN_ROOT}, $installation_list);
        write_manifest($manifest, $installed);
        fix_symlinks($ENV{RASPBIAN_ROOT});
    }
}

sub read_manifest {
    my ($filename) = @_;

    my %installed;
    if (open(my $fh, '<', $filename)) {
        while (<$fh>) {
            chomp;
            s/#.*$//;   # strip comments
            s/^\s*//;   # strip leading ws
            s/\s*$//;   # strip trailing ws
            next unless /\S/;

            $installed{$_} = 1;
        }
    }
    return \%installed;
}

sub write_manifest {
    my ($filename, @packages) = @_;
    open(my $fh, '>', $filename) or die "Opening $filename: $!";
    for my $pkg (@packages) {
        say {$fh} $pkg;
    }
}

sub filter_requested_list {
    my ($seen, $requested) = @_;

    my @filtered;
    for my $name (@$requested) {
        if ($seen->{$name}) {
            say "$name is already installed";
        }
        else {
            push(@filtered, $name);
        }
    }
    return \@filtered;
}

sub process_dependencies {
    my ($seen, $packages, $requested_packages) = @_;

    my @installation_list;

    say "Querying dependencies...";
    while (my $name = shift @$requested_packages) {
        next if $seen->{$name};
        $seen->{$name} = 1;

        my $pkg = $packages->{$name};
        next unless exists $packages->{$name};
        unshift(@installation_list, $pkg->{filename});
        push(@$requested_packages, grep { /^lib/ } @{ $pkg->{depends} });
    }
    return \@installation_list;
}

sub download_packages {
    my ($paths) = @_;
    say "Downloading packages...";
    for my $path (@$paths) {
        say "Downloading $path";
        my $deb = $path;
        $deb =~ s{.*/}{};
        system('curl', '-sL', '-o', $deb, "$ENV{RASPBIAN_MIRROR}/$path");
        exit 1 if $? != 0;
    }
}

sub install_packages {
    my ($install_root, $paths) = @_;

    say "Installing packages...";
    for my $deb (@$paths) {
        $deb =~ s{.*/}{};
        say "Installing: $deb";
        system('dpkg-deb', '-x', $deb, $install_root);
        exit 1 if $? != 0;
    }
}

sub fix_symlinks {
    my ($root) = @_;

    say "Checking $root for broken symlinks...";

    my $errors = 0;
    my $wanted = sub {
        if (-d $_ && $_ eq 'doc') {
            # Skip doc directories.
            $File::Find::prune = 1;
            return;
        }

        my $link = $_;
        return unless -l $link; # not a link

        my $dest = readlink $link;
        return if -e $dest;     # not a broken link

        my $newdest = $root . $dest;
        if (-e $newdest) {
            unlink $link;
            symlink($newdest, $link);
        }
        else {
            warn "Missing file -> $dest\n";
            $errors++;
        }
    };
    find($wanted, $root);
    return unless $errors;
    die "Internal error.\n" .
        "Please raise an issue at\n" .
        "\thttps://github.com/sdt/docker-raspberry-pi-cross-compiler/issues\n";
}

sub fetch_package_list {
    my ($url, $filename) = @_;

    say 'Fetching package list...';
    my $result = qx( curl-etag $url $filename );
    if ($result =~ / 200 /) {
        say 'Package list updated';
    }
    elsif ($result =~ / 304 /) {
        say 'Package list already up-to-date';
    }
    else {
        die $result;
    }
}

sub load_package_list {
    my ($filename) = @_;

    say 'Loading package database...';
    my @fields = qw( Package Filename Depends );
    my %wanted;
    $wanted{$_} = 1 for @fields;

    my $package = { };
    my $field;

    my %packages;

    open(my $fh, '-|', 'xzcat', $filename)
        or die "Decompressing $filename: $!\n";
    while (my $line = <$fh>) {
        chomp $line;
        if ($line eq '') {
            my $name = $package->{Package};
            if (exists $packages{$name}) {
#use Data::Dumper::Concise; print STDERR Dumper($packages{$name});
#use Data::Dumper::Concise; print STDERR Dumper($package);
                die;
            }

            $packages{$name} = {
                name => $name,
                version => $package->{Version},
                filename => $package->{Filename},
                depends => [
                    map { s/ .*$//r } split(/,\s*/, $package->{Depends} // '')
                ],
            };
            $package = { };
        }
        elsif ($line =~ /^(\S+): (.*)$/) {
            if ($wanted{$1}) {
                $package->{$1} = $2;
            }
        }
    }
    close($fh) or die "Decompressing $filename: $!\n";

    return \%packages;
}
